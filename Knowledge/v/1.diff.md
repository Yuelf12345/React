# vue中的diff算法是什么，它的工作原理是如何实现的？
    vue中的diff算法是一种智能高效的dom更新策略,解决在数据状态变化时如何最优的去更新试图的问题。
    1.原理是每当数据发生变化触发渲染的时候，vue会先构建一个虚拟dom树，然后去和上一次构建的虚拟dom树进行对比。
    2.在比较的时候，它是有同层级比较和优化策略的。首先同层级比较是指vue遵循同层级节点比较的原则，它不会去跨层级去寻找节点的差异。然后优化策略是diff里根据节点是否有key属性去优化。没有key属性的节点，里面就只做了替换、新增和删除的操作；有key的时候，它会进行双向查找，也就是从两端向中间寻找(头头，尾尾，头尾，尾头)【vue3只有前两种】，然后进行新增、删除和排序的操作。

# Vue 3 模板编译优化
1.静态提升 (Static Hoisting)
Vue 3 会自动识别模板中的静态内容并将其提升到渲染函数之外，避免在每次渲染时重新创建。
```javascript
// Vue 2 中的编译结果
function render() {
  // 每次渲染都会创建新的 VNode
  return h('div', [
    h('p', '静态文本'),
    h('p', this.dynamicValue)
  ])
}

// Vue 3 中的编译结果
const _hoisted_1 = createVNode('p', null, '静态文本', PatchFlags.HOISTED)

function render() {
  // 静态节点被提升，只创建一次
  return (_openBlock(), _createBlock('div', null, [
    _hoisted_1,
    createVNode('p', null, this.dynamicValue, PatchFlags.TEXT)
  ]))
}
```
2.预字符串化 (Pre-stringification)
对于连续的静态节点，Vue 3 会将它们预编译为字符串，进一步减少渲染开销。
```html
<div>
  <p>静态文本1</p>
  <p>静态文本2</p>
  <p>静态文本3</p>
  <p>{{ dynamicValue }}</p>
</div>
```
```javascript
// 编译结果
const _hoisted_1 = /*#__PURE__*/_createStaticVNode("<p>静态文本1</p><p>静态文本2</p><p>静态文本3</p>", 3)
function render() {
  return (_openBlock(), _createBlock('div', null, [
    _hoisted_1,
    createVNode('p', null, this.dynamicValue, PatchFlags.TEXT)
  ]))
}
```